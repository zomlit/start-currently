# Full-Stack Development Guidelines

## Project Architecture Overview

- **Frontend**: TanStack Start + React (web folder)
- **Backend**: ElysiaJS + Bun (backend folder)
- **Database**: Prisma + Supabase
- **Authentication**: Clerk
- **Type Safety**: End-to-end type safety with Prisma + Supabase types

## Project Structure

```
/
├── web/                      # Frontend application
│   ├── app/
│   │   ├── components/       # Reusable components
│   │   │   ├── ui/          # Shadcn UI components
│   │   │   ├── auth/        # Auth-related components
│   │   │   └── widget-settings/ # Widget configuration
│   │   ├── hooks/           # Custom React hooks
│   │   ├── routes/          # TanStack Router routes
│   │   ├── store/           # State management
│   │   ├── types/           # TypeScript types
│   │   └── utils/           # Utility functions
│   └── public/              # Static assets
│
├── backend/                  # Backend application
│   ├── src/
│   │   ├── routes/          # API routes
│   │   │   ├── spotify/     # Spotify integration
│   │   │   └── twitch/      # Twitch integration
│   │   ├── services/        # Business logic
│   │   ├── middleware/      # Custom middleware
│   │   └── utils/           # Utility functions
│   └── prisma/              # Database schema and migrations
```

## Core Technologies

### Frontend

- TanStack Start + React
- TanStack Router + Query
- Shadcn UI + Tailwind
- Zustand for UI state
- React Hook Form
- Clerk for authentication

### Backend

- ElysiaJS + Bun
- Prisma ORM
- Supabase
- Socket.IO for real-time
- Spotify & Twitch APIs

## Best Practices

### Frontend

1. Use TanStack Query for all server state
2. Use Zustand only for UI state
3. Implement proper error boundaries
4. Follow atomic design principles
5. Use TypeScript strict mode

### Data Fetching

1. Always use TanStack Query hooks
2. Implement proper error handling
3. Use optimistic updates
4. Handle loading states
5. Implement proper caching

```typescript
// ✅ Good: Using TanStack Query
const { data, isLoading } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
});

// ❌ Bad: Direct fetch
const [data, setData] = useState();
useEffect(() => {
  fetch("/api/todos").then(setData);
}, []);
```

### Backend

1. Use ElysiaJS decorators
2. Implement proper error handling
3. Use Prisma transactions
4. Follow RESTful principles
5. Implement rate limiting

### Type Safety

1. Use generated types
2. Use Eden for end-to-end type safety
3. No type assertions (as)
4. Strict null checks
5. Proper error types
6. Validate API responses

## Resources

- [TanStack Query](https://tanstack.com/query/latest)
- [TanStack Router](https://tanstack.com/router/latest)
- [ElysiaJS](https://elysiajs.com)
- [Eden](https://elysiajs.com/eden/overview.html)
- [Clerk](https://clerk.com)
- [Shadcn UI](https://ui.shadcn.com)

## Key Principles

- Server state in TanStack Query
- UI state in Zustand
- Type safety first
- Real-time capabilities
- Clean code practices

**NOTE**: Keep dependencies updated to latest stable versions.
